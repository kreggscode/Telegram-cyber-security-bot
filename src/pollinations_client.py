import urllib.parse
import requests
import random
import time
import re
from datetime import datetime


def clean_ai_response(text: str) -> str:
    """Remove Pollinations.ai ads and promotional content from generated text."""
    
    # Common ad patterns to remove
    ad_patterns = [
        r'(?i)pollinations\.ai.*',
        r'(?i)powered by pollinations.*',
        r'(?i)created with pollinations.*',
        r'(?i)generated by pollinations.*',
        r'(?i)visit pollinations\.ai.*',
        r'(?i)try pollinations.*',
        r'(?i)learn more at.*pollinations.*',
        r'(?i)check out pollinations.*',
        r'(?i)\*\*advertisement\*\*.*',
        r'(?i)\*\*sponsored\*\*.*',
        r'(?i)https?://pollinations\.ai\S*',
        r'(?i)https?://.*pollinations.*',
        r'(?i)Want to.*pollinations.*',
        r'(?i)Note:.*pollinations.*',
        r'(?i)Disclaimer:.*pollinations.*',
        r'(?i)---\s*This content.*',
        r'(?i)---\s*Generated.*',
        r'(?i)\[.*pollinations.*\]',
    ]
    
    cleaned_text = text
    
    # Remove each ad pattern
    for pattern in ad_patterns:
        cleaned_text = re.sub(pattern, '', cleaned_text, flags=re.MULTILINE)
    
    # Remove any standalone URLs (but keep URLs in markdown code blocks)
    lines = cleaned_text.split('\n')
    filtered_lines = []
    in_code_block = False
    
    for line in lines:
        # Track code blocks
        if line.strip().startswith('```'):
            in_code_block = not in_code_block
            filtered_lines.append(line)
            continue
        
        # If in code block, keep the line as-is
        if in_code_block:
            filtered_lines.append(line)
            continue
        
        # Outside code blocks, remove lines that are just URLs or promotional text
        if re.match(r'^\s*https?://\S+\s*$', line):
            continue
        if re.match(r'^\s*\*\*.*\*\*\s*$', line) and any(keyword in line.lower() for keyword in ['ad', 'sponsor', 'promo', 'pollination']):
            continue
        
        filtered_lines.append(line)
    
    cleaned_text = '\n'.join(filtered_lines)
    
    # Remove excessive blank lines (more than 2 consecutive)
    cleaned_text = re.sub(r'\n{3,}', '\n\n', cleaned_text)
    
    # Remove trailing/leading whitespace
    cleaned_text = cleaned_text.strip()
    
    return cleaned_text


def generate_text(prompt: str) -> str:
    """Generate free-form text from Pollinations.ai with randomization for variety."""
    # Add randomization to ensure unique content every day
    seed = random.randint(1000, 999999)
    timestamp = int(time.time())
    date_str = datetime.now().strftime("%Y-%m-%d")
    
    # Enhance prompt with context to ensure variety
    enhanced_prompt = f"{prompt}\n\nIMPORTANT: Make this unique and different. Today's date: {date_str}. Generate fresh, original content not seen before. Seed: {seed}"
    
    encoded = urllib.parse.quote(enhanced_prompt)
    # Add seed parameter to URL for additional randomization
    url = f"https://text.pollinations.ai/{encoded}?seed={seed}&timestamp={timestamp}"
    
    resp = requests.get(url, timeout=30)
    if resp.status_code == 200:
        raw_text = resp.text.strip()
        # Clean ads from the response
        cleaned_text = clean_ai_response(raw_text)
        return cleaned_text
    return "AI generation failed. Please try again."



def image_url(prompt: str) -> str:
    """Return an image URL from Pollinations based on prompt with randomization."""
    seed = random.randint(1000, 999999)
    encoded = urllib.parse.quote(prompt)
    # Add seed for image variety
    return f"https://image.pollinations.ai/prompt/{encoded}?seed={seed}"
