import urllib.parse
import requests
import random
import time
import re
from datetime import datetime


from .config import POLLINATIONS_API_KEY, AI_MODEL


def clean_ai_response(text: str) -> str:
    """Remove Pollinations.ai ads and promotional content from generated text."""
    
    # Common ad patterns to remove
    ad_patterns = [
        r'(?i)pollinations\.ai.*',
        r'(?i)powered by pollinations.*',
        r'(?i)created with pollinations.*',
        r'(?i)generated by pollinations.*',
        r'(?i)visit pollinations\.ai.*',
        r'(?i)try pollinations.*',
        r'(?i)learn more at.*pollinations.*',
        r'(?i)check out pollinations.*',
        r'(?i)\*\*advertisement\*\*.*',
        r'(?i)\*\*sponsored\*\*.*',
        r'(?i)https?://pollinations\.ai\S*',
        r'(?i)https?://.*pollinations.*',
        r'(?i)Want to.*pollinations.*',
        r'(?i)Note:.*pollinations.*',
        r'(?i)Disclaimer:.*pollinations.*',
        r'(?i)---\s*This content.*',
        r'(?i)---\s*Generated.*',
        r'(?i)\[.*pollinations.*\]',
    ]
    
    cleaned_text = text
    
    # Remove each ad pattern
    for pattern in ad_patterns:
        cleaned_text = re.sub(pattern, '', cleaned_text, flags=re.MULTILINE)
    
    # Remove any standalone URLs (but keep URLs in markdown code blocks)
    lines = cleaned_text.split('\n')
    filtered_lines = []
    in_code_block = False
    
    for line in lines:
        # Track code blocks
        if line.strip().startswith('```'):
            in_code_block = not in_code_block
            filtered_lines.append(line)
            continue
        
        # If in code block, keep the line as-is
        if in_code_block:
            filtered_lines.append(line)
            continue
        
        # Outside code blocks, remove lines that are just URLs or promotional text
        if re.match(r'^\s*https?://\S+\s*$', line):
            continue
        if re.match(r'^\s*\*\*.*\*\*\s*$', line) and any(keyword in line.lower() for keyword in ['ad', 'sponsor', 'promo', 'pollination']):
            continue
        
        filtered_lines.append(line)
    
    cleaned_text = '\n'.join(filtered_lines)
    
    # Remove excessive blank lines (more than 2 consecutive)
    cleaned_text = re.sub(r'\n{3,}', '\n\n', cleaned_text)
    
    # Remove trailing/leading whitespace
    cleaned_text = cleaned_text.strip()
    
    return cleaned_text


def generate_text(prompt: str) -> str:
    """Generate text from Pollinations.ai using the paid API gateway."""
    # Add randomization to ensure unique content
    seed = random.randint(1000, 999999)
    date_str = datetime.now().strftime("%Y-%m-%d")
    
    # Enhance prompt with context
    enhanced_prompt = f"{prompt}\n\nIMPORTANT: Make this unique and different. Today's date: {date_str}. Generate fresh, original content. Seed: {seed}"
    
    url = "https://gen.pollinations.ai/v1/chat/completions"
    
    headers = {
        "Content-Type": "application/json"
    }
    if POLLINATIONS_API_KEY:
        headers["Authorization"] = f"Bearer {POLLINATIONS_API_KEY}"
    
    data = {
        "model": AI_MODEL if AI_MODEL else "openai",
        "messages": [{"role": "user", "content": enhanced_prompt}],
        "seed": seed
    }
    
    try:
        resp = requests.post(url, headers=headers, json=data, timeout=60)
        if resp.status_code == 200:
            result = resp.json()
            raw_text = result['choices'][0]['message']['content'].strip()
            # Clean ads from the response
            cleaned_text = clean_ai_response(raw_text)
            return cleaned_text
        else:
            print(f"Error calling Pollinations API: {resp.status_code} - {resp.text}")
    except Exception as e:
        print(f"Exception during AI generation: {str(e)}")
        
    return "AI generation failed. Please try again."


def image_url(prompt: str) -> str:
    """Return an image URL from Pollinations based on prompt with authentication."""
    seed = random.randint(1000, 999999)
    encoded = urllib.parse.quote(prompt)
    
    # Use the unified gateway for images
    # We use query param authentication for the URL so it can be passed directly to Telegram
    base_url = f"https://gen.pollinations.ai/image/{encoded}"
    params = [
        f"seed={seed}",
        "width=1024",
        "height=1024",
        "model=flux-large" # Using flux-large for high quality
    ]
    
    if POLLINATIONS_API_KEY:
        params.append(f"key={POLLINATIONS_API_KEY}")
        
    return f"{base_url}?{'&'.join(params)}"
