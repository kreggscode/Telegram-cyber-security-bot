import urllib.parse
import requests
import random
import time
import re
from datetime import datetime


from .config import POLLINATIONS_API_KEY, AI_MODEL


def clean_ai_response(text: str) -> str:
    """Remove Pollinations.ai ads and promotional content from generated text."""
    
    # Common ad patterns to remove
    ad_patterns = [
        r'(?i)pollinations\.ai.*',
        r'(?i)powered by pollinations.*',
        r'(?i)created with pollinations.*',
        r'(?i)generated by pollinations.*',
        r'(?i)visit pollinations\.ai.*',
        r'(?i)try pollinations.*',
        r'(?i)learn more at.*pollinations.*',
        r'(?i)check out pollinations.*',
        r'(?i)\*\*advertisement\*\*.*',
        r'(?i)\*\*sponsored\*\*.*',
        r'(?i)https?://pollinations\.ai\S*',
        r'(?i)https?://.*pollinations.*',
        r'(?i)Want to.*pollinations.*',
        r'(?i)Note:.*pollinations.*',
        r'(?i)Disclaimer:.*pollinations.*',
        r'(?i)---\s*This content.*',
        r'(?i)---\s*Generated.*',
        r'(?i)\[.*pollinations.*\]',
    ]
    
    cleaned_text = text
    
    # Remove each ad pattern
    for pattern in ad_patterns:
        cleaned_text = re.sub(pattern, '', cleaned_text, flags=re.MULTILINE)
    
    # Remove any standalone URLs (but keep URLs in markdown code blocks)
    lines = cleaned_text.split('\n')
    filtered_lines = []
    in_code_block = False
    
    for line in lines:
        # Track code blocks
        if line.strip().startswith('```'):
            in_code_block = not in_code_block
            filtered_lines.append(line)
            continue
        
        # If in code block, keep the line as-is
        if in_code_block:
            filtered_lines.append(line)
            continue
        
        # Outside code blocks, remove lines that are just URLs or promotional text
        if re.match(r'^\s*https?://\S+\s*$', line):
            continue
        if re.match(r'^\s*\*\*.*\*\*\s*$', line) and any(keyword in line.lower() for keyword in ['ad', 'sponsor', 'promo', 'pollination']):
            continue
        
        filtered_lines.append(line)
    
    cleaned_text = '\n'.join(filtered_lines)
    
    # Remove excessive blank lines (more than 2 consecutive)
    cleaned_text = re.sub(r'\n{3,}', '\n\n', cleaned_text)
    
    # Remove trailing/leading whitespace
    cleaned_text = cleaned_text.strip()
    
    return cleaned_text


def generate_text(prompt: str, max_retries: int = 3) -> str:
    """Generate text from Pollinations.ai using the paid API gateway EXCLUSIVELY."""
    if not POLLINATIONS_API_KEY:
        print("CRITICAL: POLLINATIONS_API_KEY is missing. Paid API required.")
        return "AI Error: System configuration missing (API Key)."

    # Add randomization to ensure unique content
    seed = random.randint(1000, 999999)
    date_str = datetime.now().strftime("%Y-%m-%d")
    
    # Minimal context to avoid AI 'dreaming' or discussing the instructions
    enhanced_prompt = f"{prompt}\n\nSTRICT: Do not include introductory text like 'Certainly' or 'Here is...'. Do not mention the date or seed. Return ONLY the requested content. (Seed: {seed})"
    
    url = "https://gen.pollinations.ai/v1/chat/completions"
    headers = {
        "Authorization": f"Bearer {POLLINATIONS_API_KEY}",
        "Content-Type": "application/json"
    }
    
    # Use gemini-fast if specified, otherwise fallback to openai
    model = AI_MODEL if AI_MODEL else "openai"
    
    data = {
        "model": model,
        "messages": [{"role": "user", "content": enhanced_prompt}],
        "seed": seed
    }
    
    for attempt in range(max_retries):
        try:
            print(f"--- POLLINATIONS PAID API VERIFIED ---")
            print(f"Endpoint: {url}")
            print(f"Model ID: {model}")
            print(f"Key Present: {bool(POLLINATIONS_API_KEY)}")
            resp = requests.post(url, headers=headers, json=data, timeout=120)
            
            if resp.status_code == 200:
                result = resp.json()
                if 'choices' in result and len(result['choices']) > 0:
                    raw_text = result['choices'][0]['message']['content'].strip()
                    # Clean ads from the response
                    cleaned_text = clean_ai_response(raw_text)
                    return cleaned_text
                else:
                    print(f"Unexpected API response structure: {result}")
            elif resp.status_code == 401:
                print("Error: Unauthorized. Please check your POLLINATIONS_API_KEY.")
                return "AI Error: Unauthorized. Check API Key."
            elif resp.status_code == 429:
                print("Error: Rate limited. Waiting before retry...")
                time.sleep(5 * (attempt + 1))
            else:
                print(f"Error calling Pollinations API: {resp.status_code} - {resp.text}")
                
        except Exception as e:
            print(f"Exception during AI generation attempt {attempt + 1}: {str(e)}")
            time.sleep(2)
        
    return "AI generation failed after multiple attempts (Paid API)."


def image_url(prompt: str) -> str:
    """Return an image URL from Pollinations based on prompt with authentication."""
    seed = random.randint(1000, 999999)
    encoded = urllib.parse.quote(prompt)
    
    # Use the unified gateway for images
    print("--- POLLINATIONS PAID IMAGE API VERIFIED ---")
    print(f"Base: https://gen.pollinations.ai/image/{encoded}")
    print(f"Key Present: {bool(POLLINATIONS_API_KEY)}")
    base_url = f"https://gen.pollinations.ai/image/{encoded}"
    params = [
        f"seed={seed}",
        "width=1024",
        "height=1024",
        "model=flux-large" # Using flux-large for high quality
    ]
    
    if POLLINATIONS_API_KEY:
        params.append(f"key={POLLINATIONS_API_KEY}")
        
    return f"{base_url}?{'&'.join(params)}"
